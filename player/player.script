local gamepads = require("input.gamepads")

-- Crosshair tints, 4 player max
local cross_tints = {}
cross_tints[1] = vmath.vector4(1,0,0,1)
cross_tints[2] = vmath.vector4(1,1,0,1)
cross_tints[3] = vmath.vector4(0,1,0,1)
cross_tints[4] = vmath.vector4(0,1,1,1)

local BULLET_OFFSET = vmath.vector3(0, 100, 0)

go.property("health", 100)
go.property("crosshair_speed", 5000)
go.property("player_speed", 700)
go.property("player_jump_speed", 1500)
go.property("velocity", vmath.vector3(0,0,0))
go.property("gamepad_id", 0)

local function spawn_bullet(angle, properties)
	factory.create("/controller#bullet_factory", go.get_world_position() + vmath.rotate(angle, BULLET_OFFSET), angle, properties, 0.2)
end

local function spawn_shell()
	local vel = vmath.vector3(math.random()*200-100, 1000, 0)
	factory.create("/controller#shell_factory", go.get_world_position(), vmath.quat(), {velocity = vel, angular_velocity = 10}, 0.15)
	--msg.post("/game", "spawn_shell", { position = go.get_world_position() })
end

local WEAPONS = {
	{
		name = "AK-97",
		bullets_per_second = 10,
		magazine_size = 2000,
		spread = 5,
		reload_time = 1.5,
		move_and_fire = true,
		fire_bullet = function(self, angle)
			spawn_bullet(angle, { speed = 2000, type = BULLET, damage = 1 })
			spawn_shell()
			--sounds.fire_bullet()
		end
	},
}

local function change_weapon(self, index)
	self.weapon = WEAPONS[index]
	self.weapon_angle = vmath.quat()
	self.bullets_left = self.weapon.magazine_size
	self.magazines = 5
	self.bullet_interval = 1 / self.weapon.bullets_per_second
	self.velocity = vmath.vector3()
	self.correction = vmath.vector3()
	self.bullets_fired_in_burts = 0
	--msg.post("lasersight", self.weapon.lasersight and "enable" or "disable")
	--update_weapon_text(self)
end

local function take_damage(self, damage)
	if self.health > 0 then
		self.health = math.max(0, self.health - damage)
		label.set_text("#label", "Health: " .. self.health)
		if self.health == 0 then
			input.release()
			msg.post("lasersight", "disable")
			broadcast.send("player_dead")
		else
			--explosions.small(go.get_world_position())
		end
	end
end

local function init_gp(self)
	self.gp = gamepads.init_gamepad()
end

function init(self)
	msg.post(".", "acquire_input_focus")
	print("PLAYER INIT! gp id: " .. tostring(self.gamepad_id))

	math.randomseed(socket.gettime())

	self.gp = {}
	self.is_jumping = false
	self.correction_physics = vmath.vector3(0)
	self.weapon_angle = vmath.quat()
	change_weapon(self, 1)

	init_gp(self)

	go.set("crosshair#sprite", "tint", cross_tints[self.gamepad_id + 1])
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	self.correction_physics = vmath.vector3()
	
	local pos_player = go.get_position()
	
	-- update position (gravity etc.)
	self.velocity.y = self.velocity.y + (4 * (-(9.82)))
	pos_player.y = pos_player.y + self.velocity.y * dt
	
	-- gamepad input
	pos_player.x = pos_player.x + self.gp.stick_values.stick_left.x * dt * self.player_speed
	go.set_position(pos_player)

	local pos_cross = go.get_position("crosshair")
	
	pos_cross.x = pos_cross.x + self.gp.stick_values.stick_right.x * dt * self.crosshair_speed
	pos_cross.y = pos_cross.y + self.gp.stick_values.stick_right.y * dt * self.crosshair_speed
	if vmath.length(pos_cross) > 350 then
		pos_cross = vmath.normalize(pos_cross) * 350
	end

	go.set_position(pos_cross, "crosshair")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") and message.distance > 0 then
		local proj = vmath.project(self.correction_physics, message.normal * message.distance)

		if proj < 1 then
			-- Only care for projections that does not overshoot.
			local comp = (message.distance - message.distance * proj) * message.normal
			-- Apply compensation
			
			if message.normal.y > 0 then -- no wall jumps!
				self.is_jumping = false
			end
			local comp = (message.distance - message.distance * proj) * message.normal
			local new_pos = go.get_position() + comp
			self.correction_physics = self.correction_physics + comp
			go.set_position(new_pos)
			self.velocity.x = self.velocity.x - self.velocity.x * math.abs(message.normal.x)
			self.velocity.y = self.velocity.y - self.velocity.y * math.abs(message.normal.y)
			self.velocity.z = self.velocity.z - self.velocity.z * math.abs(message.normal.z)
		end

		if message.other_group == hash("bullet") then
			local damage = go.get(msg.url(nil, message.other_id, "bullet"), hash("damage")) or 1
			print("DAMAGE: " .. tostring(damage))
			take_damage(self, damage)
		end
	end
end

function on_input(self, action_id, action)
	if action_id ~= nil then
		--print(action_id, action.value)
	end

	-- gamepad
	if action.gamepad ~= nil and action.gamepad == self.gamepad_id then
		label.set_text("#label", "Gamepad id: " .. tostring(self.gamepad_id))
		--gp.on_input(self, action_id, action)
		
		--gamepads[self.gamepad_id].on_input(self, action_id, action)
		--self.gp.on_input(self, action_id, action)
		self.gp = gamepads.on_input(self, action_id, action, self.gp)

		------ Handle gamepad state
		-- jump!
		if self.gp.pad_values.right.down == 1 and action.pressed and self.is_jumping == false then
			self.is_jumping = true
			self.velocity.y = self.velocity.y + self.player_jump_speed
		end
		-- fire!
		if self.gp.trigger_values.trigger_right > 0 then
			local now = socket.gettime()
			if not self.last_bullet or (now - self.last_bullet) >= self.bullet_interval then
				if self.bullets_left > 0 then
					self.weapon.fire_bullet(self, self.weapon_angle)
					self.bullets_left = self.bullets_left - 1
					self.bullets_fired_in_burts = self.bullets_fired_in_burts + 1
					--update_weapon_text(self)
				--else
					--sounds.no_ammo()
				end
				self.last_bullet = now
			end
		end
		-- aim
		local aim_vec = go.get_world_position("crosshair") - go.get_world_position()
		local angle = -math.atan2(aim_vec.x, aim_vec.y)
		-- add weapon spread to angle
		local spread_rad = self.weapon.spread * math.pi / 180
		local spread_rand = (math.random() * 2 - 1) * spread_rad
		angle = angle + spread_rand
		local quat = vmath.quat_rotation_z(angle)
		self.weapon_angle = quat
		
	end

	-- keyboard (for debug)
	if action_id == hash("KEY_SPACE") and action.pressed then
		self.velocity.y = self.velocity.y + self.player_jump_speed
	elseif action_id == hash("KEY_A") then
		if action.pressed then
			self.gp.stick_values.stick_left.x = -1
		elseif action.released then
			self.gp.stick_values.stick_left.x = 0
		end
	elseif action_id == hash("KEY_D") then
		if action.pressed then
			self.gp.stick_values.stick_left.x = 1
		elseif action.released then
			self.gp.stick_values.stick_left.x = 0
		end
	elseif action_id == hash("KEY_W") then
		if action.pressed then
			self.gp.stick_values.stick_left.y = 1
		elseif action.released then
			self.gp.stick_values.stick_left.y = 0
		end
	elseif action_id == hash("KEY_S") then
		if action.pressed then
			self.gp.stick_values.stick_left.y = -1
		elseif action.released then
			self.gp.stick_values.stick_left.y = 0
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
